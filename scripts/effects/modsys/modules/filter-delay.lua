---
--- Generated by Luanalysis
--- Created by Lyr.
--- DateTime: 1/24/2021 9:33 PM
---


--[[
  INPUT:  *
  CFG:    duration      float               Duration to delay events
          resetOnEvent  boolean   false     Resets the timer when a new event is received
          discardEarly  boolean   true      Discard events that come while there's an event on duration queue. Reset, if true, still happens on discard
--]]

if not Modsys then error("This script isn't supposed to be require'd yourself lol.") end
---@type Modsys, Filter
local Modsys, Filter = Modsys, Filter

---@class Delay : Filter
local Delay = Filter.new()

function Delay:init()
  self.storage.queue = self:storageDefault("queue", {})
end

function Delay:update(dt)
  for i, data in pairs(self.storage.queue) do   -- pairs allows table.remove while in loop no problem
    data._delayTimer = data._delayTimer - dt
    if data._delayTimer <= 0 then
      table.remove(self.storage.queue, i)
      data._delayTimer = nil
      self:emit(data)
    end
  end
end

function Delay:uninit()
  -- normal uninit
end

function Delay:process(data)
  if self.cfg.resetOnEvent then
    for _,v in pairs(self.storage.queue) do
      v._delayTimer = self.cfg.duration
    end
  end
  if self.cfg.discardEarly and next(self.storage.queue) then return end

  data._delayTimer = self.cfg.duration
  table.insert(self.storage.queue, data)
  return --nothing--
end
